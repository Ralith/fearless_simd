// This file is autogenerated by fearless_simd_gen

use crate::{Simd, SimdInto};
use crate::{
    f32x4, f32x8, i8x16, i8x32, i16x8, i16x16, i32x4, i32x8, mask8x16, mask8x32, mask16x8,
    mask16x16, mask32x4, mask32x8, u8x16, u8x32, u16x8, u16x16, u32x4, u32x8,
};
impl<S: Simd> core::ops::Add for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_f32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<f32> for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: f32) -> Self::Output {
        self.simd.add_f32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<f32x4<S>> for f32 {
    type Output = f32x4<S>;
    #[inline(always)]
    fn add(self, rhs: f32x4<S>) -> Self::Output {
        rhs.simd.add_f32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Sub for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn sub(self, rhs: Self) -> Self::Output {
        self.simd.sub_f32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Sub<f32> for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn sub(self, rhs: f32) -> Self::Output {
        self.simd.sub_f32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Sub<f32x4<S>> for f32 {
    type Output = f32x4<S>;
    #[inline(always)]
    fn sub(self, rhs: f32x4<S>) -> Self::Output {
        rhs.simd.sub_f32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Mul for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn mul(self, rhs: Self) -> Self::Output {
        self.simd.mul_f32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Mul<f32> for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn mul(self, rhs: f32) -> Self::Output {
        self.simd.mul_f32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Mul<f32x4<S>> for f32 {
    type Output = f32x4<S>;
    #[inline(always)]
    fn mul(self, rhs: f32x4<S>) -> Self::Output {
        rhs.simd.mul_f32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Div for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn div(self, rhs: Self) -> Self::Output {
        self.simd.div_f32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Div<f32> for f32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn div(self, rhs: f32) -> Self::Output {
        self.simd.div_f32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Div<f32x4<S>> for f32 {
    type Output = f32x4<S>;
    #[inline(always)]
    fn div(self, rhs: f32x4<S>) -> Self::Output {
        rhs.simd.div_f32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for i8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i8x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i8> for i8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i8) -> Self::Output {
        self.simd.add_i8x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i8x16<S>> for i8 {
    type Output = i8x16<S>;
    #[inline(always)]
    fn add(self, rhs: i8x16<S>) -> Self::Output {
        rhs.simd.add_i8x16(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u8x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u8> for u8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u8) -> Self::Output {
        self.simd.add_u8x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u8x16<S>> for u8 {
    type Output = u8x16<S>;
    #[inline(always)]
    fn add(self, rhs: u8x16<S>) -> Self::Output {
        rhs.simd.add_u8x16(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask8x16(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask8x16(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask8x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask8x16<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask8x16(self)
    }
}
impl<S: Simd> core::ops::Add for i16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i16x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i16> for i16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i16) -> Self::Output {
        self.simd.add_i16x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i16x8<S>> for i16 {
    type Output = i16x8<S>;
    #[inline(always)]
    fn add(self, rhs: i16x8<S>) -> Self::Output {
        rhs.simd.add_i16x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u16x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u16> for u16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u16) -> Self::Output {
        self.simd.add_u16x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u16x8<S>> for u16 {
    type Output = u16x8<S>;
    #[inline(always)]
    fn add(self, rhs: u16x8<S>) -> Self::Output {
        rhs.simd.add_u16x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask16x8(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask16x8(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask16x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask16x8<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask16x8(self)
    }
}
impl<S: Simd> core::ops::Add for i32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i32> for i32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i32) -> Self::Output {
        self.simd.add_i32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i32x4<S>> for i32 {
    type Output = i32x4<S>;
    #[inline(always)]
    fn add(self, rhs: i32x4<S>) -> Self::Output {
        rhs.simd.add_i32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u32> for u32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u32) -> Self::Output {
        self.simd.add_u32x4(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u32x4<S>> for u32 {
    type Output = u32x4<S>;
    #[inline(always)]
    fn add(self, rhs: u32x4<S>) -> Self::Output {
        rhs.simd.add_u32x4(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask32x4(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask32x4<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask32x4(self)
    }
}
impl<S: Simd> core::ops::Add for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_f32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<f32> for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: f32) -> Self::Output {
        self.simd.add_f32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<f32x8<S>> for f32 {
    type Output = f32x8<S>;
    #[inline(always)]
    fn add(self, rhs: f32x8<S>) -> Self::Output {
        rhs.simd.add_f32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Sub for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn sub(self, rhs: Self) -> Self::Output {
        self.simd.sub_f32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Sub<f32> for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn sub(self, rhs: f32) -> Self::Output {
        self.simd.sub_f32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Sub<f32x8<S>> for f32 {
    type Output = f32x8<S>;
    #[inline(always)]
    fn sub(self, rhs: f32x8<S>) -> Self::Output {
        rhs.simd.sub_f32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Mul for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn mul(self, rhs: Self) -> Self::Output {
        self.simd.mul_f32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Mul<f32> for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn mul(self, rhs: f32) -> Self::Output {
        self.simd.mul_f32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Mul<f32x8<S>> for f32 {
    type Output = f32x8<S>;
    #[inline(always)]
    fn mul(self, rhs: f32x8<S>) -> Self::Output {
        rhs.simd.mul_f32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Div for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn div(self, rhs: Self) -> Self::Output {
        self.simd.div_f32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Div<f32> for f32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn div(self, rhs: f32) -> Self::Output {
        self.simd.div_f32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Div<f32x8<S>> for f32 {
    type Output = f32x8<S>;
    #[inline(always)]
    fn div(self, rhs: f32x8<S>) -> Self::Output {
        rhs.simd.div_f32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for i8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i8x32(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i8> for i8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i8) -> Self::Output {
        self.simd.add_i8x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i8x32<S>> for i8 {
    type Output = i8x32<S>;
    #[inline(always)]
    fn add(self, rhs: i8x32<S>) -> Self::Output {
        rhs.simd.add_i8x32(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u8x32(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u8> for u8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u8) -> Self::Output {
        self.simd.add_u8x32(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u8x32<S>> for u8 {
    type Output = u8x32<S>;
    #[inline(always)]
    fn add(self, rhs: u8x32<S>) -> Self::Output {
        rhs.simd.add_u8x32(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask8x32(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask8x32(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask8x32(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask8x32<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask8x32(self)
    }
}
impl<S: Simd> core::ops::Add for i16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i16x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i16> for i16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i16) -> Self::Output {
        self.simd.add_i16x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i16x16<S>> for i16 {
    type Output = i16x16<S>;
    #[inline(always)]
    fn add(self, rhs: i16x16<S>) -> Self::Output {
        rhs.simd.add_i16x16(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u16x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u16> for u16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u16) -> Self::Output {
        self.simd.add_u16x16(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u16x16<S>> for u16 {
    type Output = u16x16<S>;
    #[inline(always)]
    fn add(self, rhs: u16x16<S>) -> Self::Output {
        rhs.simd.add_u16x16(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask16x16(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask16x16(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask16x16(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask16x16<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask16x16(self)
    }
}
impl<S: Simd> core::ops::Add for i32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_i32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<i32> for i32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: i32) -> Self::Output {
        self.simd.add_i32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<i32x8<S>> for i32 {
    type Output = i32x8<S>;
    #[inline(always)]
    fn add(self, rhs: i32x8<S>) -> Self::Output {
        rhs.simd.add_i32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::Add for u32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: Self) -> Self::Output {
        self.simd.add_u32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Add<u32> for u32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn add(self, rhs: u32) -> Self::Output {
        self.simd.add_u32x8(self, rhs.simd_into(self.simd))
    }
}
impl<S: Simd> core::ops::Add<u32x8<S>> for u32 {
    type Output = u32x8<S>;
    #[inline(always)]
    fn add(self, rhs: u32x8<S>) -> Self::Output {
        rhs.simd.add_u32x8(self.simd_into(rhs.simd), rhs)
    }
}
impl<S: Simd> core::ops::BitAnd for mask32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.simd.and_mask32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::BitOr for mask32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.simd.or_mask32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::BitXor for mask32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.simd.xor_mask32x8(self, rhs)
    }
}
impl<S: Simd> core::ops::Not for mask32x8<S> {
    type Output = Self;
    #[inline(always)]
    fn not(self) -> Self::Output {
        self.simd.not_mask32x8(self)
    }
}
